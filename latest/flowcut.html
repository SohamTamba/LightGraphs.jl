<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flow and Cut · LightGraphs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="graphtypes.html">Choosing A Graph Type</a></li><li><a class="toctext" href="types.html">LightGraphs Types</a></li><li><a class="toctext" href="basicproperties.html">Accessing Properties</a></li><li><a class="toctext" href="generators.html">Making and Modifying Graphs</a></li><li><a class="toctext" href="persistence.html">Reading / Writing Graphs</a></li><li><a class="toctext" href="operators.html">Operators</a></li><li><a class="toctext" href="plotting.html">Plotting Graphs</a></li><li><a class="toctext" href="pathing.html">Path and Traversal</a></li><li><a class="toctext" href="distance.html">Distance</a></li><li><a class="toctext" href="centrality.html">Centrality Measures</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="matching.html">Matching</a></li><li><a class="toctext" href="community.html">Community Structures</a></li><li><a class="toctext" href="degeneracy.html">Degeneracy</a></li><li class="current"><a class="toctext" href="flowcut.html">Flow and Cut</a><ul class="internal"><li><a class="toctext" href="#Full-Docs-1">Full Docs</a></li></ul></li><li><a class="toctext" href="integration.html">Integration with other packages</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="developing.html">Developer Notes</a></li><li><a class="toctext" href="license.html">License Information</a></li><li><a class="toctext" href="citing.html">Citing LightGraphs</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="flowcut.html">Flow and Cut</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/master/docs/src/flowcut.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Flow and Cut</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Flow-and-Cut-1" href="#Flow-and-Cut-1">Flow and Cut</a></h1><p><em>LightGraphs.jl</em> provides different algorithms for <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">maximum flow</a> and minimum cut computations, including:</p><ul><li><a href="flowcut.html#LightGraphs.BoykovKolmogorovAlgorithm"><code>LightGraphs.BoykovKolmogorovAlgorithm</code></a></li><li><a href="flowcut.html#LightGraphs.DinicAlgorithm"><code>LightGraphs.DinicAlgorithm</code></a></li><li><a href="flowcut.html#LightGraphs.EdmondsKarpAlgorithm"><code>LightGraphs.EdmondsKarpAlgorithm</code></a></li><li><a href="flowcut.html#LightGraphs.ExtendedMultirouteFlowAlgorithm"><code>LightGraphs.ExtendedMultirouteFlowAlgorithm</code></a></li><li><a href="flowcut.html#LightGraphs.KishimotoAlgorithm"><code>LightGraphs.KishimotoAlgorithm</code></a></li><li><a href="flowcut.html#LightGraphs.PushRelabelAlgorithm"><code>LightGraphs.PushRelabelAlgorithm</code></a></li><li><a href="flowcut.html#LightGraphs.maximum_flow"><code>LightGraphs.maximum_flow</code></a></li><li><a href="flowcut.html#LightGraphs.multiroute_flow-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{R}, Tuple{T}} where T where R&lt;:Real"><code>LightGraphs.multiroute_flow</code></a></li></ul><h2><a class="nav-anchor" id="Full-Docs-1" href="#Full-Docs-1">Full Docs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.BoykovKolmogorovAlgorithm" href="#LightGraphs.BoykovKolmogorovAlgorithm"><code>LightGraphs.BoykovKolmogorovAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">BoykovKolmogorovAlgorithm &lt;: AbstractFlowAlgorithm</code></pre><p>Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/maximum_flow.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DinicAlgorithm" href="#LightGraphs.DinicAlgorithm"><code>LightGraphs.DinicAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">DinicAlgorithm &lt;: AbstractFlowAlgorithm</code></pre><p>Forces the maximum_flow function to use Dinic&#39;s algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/maximum_flow.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.EdmondsKarpAlgorithm" href="#LightGraphs.EdmondsKarpAlgorithm"><code>LightGraphs.EdmondsKarpAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">EdmondsKarpAlgorithm &lt;: AbstractFlowAlgorithm</code></pre><p>Forces the maximum_flow function to use the Edmonds–Karp algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/maximum_flow.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.PushRelabelAlgorithm" href="#LightGraphs.PushRelabelAlgorithm"><code>LightGraphs.PushRelabelAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Forces the maximum_flow function to use the Push-Relabel algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/maximum_flow.jl#L29-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maximum_flow" href="#LightGraphs.maximum_flow"><code>LightGraphs.maximum_flow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">maximum_flow(flow_graph, source, target[, capacity_matrix][, algorithm][, restriction])</code></pre><p>Generic maximum_flow function for <code>flow_graph</code> from <code>source</code> to <code>target</code> with capacities in <code>capacity_matrix</code>. Uses flow algorithm <code>algorithm</code> and cutoff restriction <code>restriction</code>.</p><ul><li><p>If <code>capacity_matrix</code> is not specified, <code>DefaultCapacity(flow_graph)</code> will be used.</p></li><li><p>If <code>algorithm</code> is not specified, it will default to <a href="flowcut.html#LightGraphs.PushRelabelAlgorithm"><code>PushRelabelAlgorithm</code></a>.</p></li><li><p>If <code>restriction</code> is not specified, it will default to <code>0</code>.</p></li></ul><p>Return a tuple of (maximum flow, flow matrix). For the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.</p><p><strong>Usage Example:</strong></p><pre><code class="language-julia-repl">julia&gt; flow_graph = DiGraph(8) # Create a flow-graph
julia&gt; flow_edges = [
(1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),
(2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),
(5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)
]

julia&gt; capacity_matrix = zeros(Int, 8, 8)  # Create a capacity matrix

julia&gt; for e in flow_edges
    u, v, f = e
    add_edge!(flow_graph, u, v)
    capacity_matrix[u,v] = f
end

julia&gt; f, F = maximum_flow(flow_graph, 1, 8) # Run default maximum_flow (push-relabel) without the capacity_matrix

julia&gt; f, F = maximum_flow(flow_graph, 1, 8, capacity_matrix) # Run default maximum_flow with the capacity_matrix

julia&gt; f, F = maximum_flow(flow_graph, 1, 8, capacity_matrix, algorithm=EdmondsKarpAlgorithm()) # Run Edmonds-Karp algorithm

julia&gt; f, F = maximum_flow(flow_graph, 1, 8, capacity_matrix, algorithm=DinicAlgorithm()) # Run Dinic&#39;s algorithm

julia&gt; f, F, labels = maximum_flow(flow_graph, 1, 8, capacity_matrix, algorithm=BoykovKolmogorovAlgorithm()) # Run Boykov-Kolmogorov algorithm
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/maximum_flow.jl#L122-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.ExtendedMultirouteFlowAlgorithm" href="#LightGraphs.ExtendedMultirouteFlowAlgorithm"><code>LightGraphs.ExtendedMultirouteFlowAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ExtendedMultirouteFlowAlgorithm</code></pre><p>Used to specify the Extended Multiroute Flow algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/multiroute_flow.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.KishimotoAlgorithm" href="#LightGraphs.KishimotoAlgorithm"><code>LightGraphs.KishimotoAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">KishimotoAlgorithm</code></pre><p>Used to specify the Kishimoto algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/multiroute_flow.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.multiroute_flow-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{R}, Tuple{T}} where T where R&lt;:Real" href="#LightGraphs.multiroute_flow-Union{Tuple{LightGraphs.AbstractGraph,Integer,Integer,AbstractArray{T,2}}, Tuple{LightGraphs.AbstractGraph,Integer,Integer}, Tuple{R}, Tuple{T}} where T where R&lt;:Real"><code>LightGraphs.multiroute_flow</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">multiroute_flow(flow_graph, source, target[, DefaultCapacity][, flow_algorithm][, mrf_algorithm][, routes])</code></pre><p>The generic multiroute_flow function.</p><p>The output will vary depending on the input:</p><ul><li><p>When the number of <code>route</code>s is <code>0</code>, return the set of breaking points of</p></li></ul><p>the multiroute flow.</p><ul><li><p>When the number of <code>route</code>s is <code>1</code>, return a flow with a set of 1-disjoint paths</p></li></ul><p>(this is the classical max-flow implementation).</p><ul><li><p>When the input is limited to a set of breaking points and a route value <code>k</code>,</p></li></ul><p>return only the k-route flow.</p><ul><li><p>Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the</p></li></ul><p>max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.</p><p>When the input is a network, it requires the following arguments:</p><ul><li><p><code>flow_graph</code>: the input graph</p></li><li><p><code>source</code>: the source vertex</p></li><li><p><code>target</code>: the target vertex</p></li><li><p><code>capacity_matrix</code>: matrix of edge flow capacities</p></li><li><p><code>flow_algorithm</code>: keyword argument for flow algorithm</p></li><li><p><code>mrf_algorithm</code>: keyword argument for multiroute flow algorithm</p></li><li><p><code>routes</code>: keyword argument for the number of routes</p></li></ul><p>When the input is only the set of (breaking) points and the number of route, it requires the following arguments:</p><ul><li><p><code>breakingpoints</code>: vector of breaking points</p></li><li><p><code>routes</code>: number of routes</p></li></ul><p>When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:</p><ul><li><p><code>breakingpoints</code>: vector of breaking points</p></li><li><p><code>routes</code>: number of routes</p></li><li><p><code>flow_graph</code>: the input graph</p></li><li><p><code>source</code>: the source vertex</p></li><li><p><code>target</code>: the target vertex</p></li><li><p><code>capacity_matrix</code>: matrix of edge flow capacities</p></li><li><p><code>flow_algorithm</code>: keyword argument for flow algorithm</p></li></ul><p>The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of <code>1</code> is assumed for each link if no capacity matrix is provided.</p><p>The <code>mrf_algorithm</code> keyword is inforced to Extended Multiroute Flow in the following cases:</p><ul><li><p>The number of routes is non-integer</p></li><li><p>The number of routes is 0 or non-specified</p></li></ul><p><strong>Usage Example :</strong></p><p>(please consult the  <a href="flowcut.html#LightGraphs.maximum_flow"><code>maximum_flow</code></a> section for options about flow_algorithm and capacity_matrix)</p><pre><code class="language-julia-repl">julia&gt; flow_graph = DiGraph(8) # Create a flow graph

julia&gt; flow_edges = [
(1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),
(2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),
(5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)
]

julia&gt; capacity_matrix = zeros(Int, 8, 8) # Create a capacity matrix

julia&gt; for e in flow_edges
    u, v, f = e
    add_edge!(flow_graph, u, v)
    capacity_matrix[u, v] = f
end

julia&gt; f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2) # Run default multiroute_flow with an integer number of routes = 2

julia&gt; f, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5) # Run default multiroute_flow with a noninteger number of routes = 1.5

julia&gt; points = multiroute_flow(flow_graph, 1, 8, capacity_matrix) # Run default multiroute_flow for all the breaking points values

julia&gt; f, F = multiroute_flow(points, 1.5) # Then run multiroute flow algorithm for any positive number of routes

julia&gt; f = multiroute_flow(points, 1.5, valueonly = true)

julia&gt; f, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix, algorithm = BoykovKolmogorovAlgorithm(), routes = 2) # Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as maximum_flow routine
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/f86953c4a42f392ee13e273c918ff12ab9402055/src/flow/multiroute_flow.jl#L99-L188">source</a></section><footer><hr/><a class="previous" href="degeneracy.html"><span class="direction">Previous</span><span class="title">Degeneracy</span></a><a class="next" href="integration.html"><span class="direction">Next</span><span class="title">Integration with other packages</span></a></footer></article></body></html>
